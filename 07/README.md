# BASH - это не ЯП, а интерпретатор

## Перенаправления
у каждого процесса свои файловые дескрипторы:
```
ls -l /dev/std*
```
так можно направлять вывод (output и error туда же):
```
echo 'hello' > /dev/null 2>&
echo 'hello' &> /dev/null # (сокращенно)
mysql < file.sql

wc -l << EOF Ssss
Sdsd
Sdsd
EOF
```
pipe:
```
ls -la | grep test
или так:
grep test ls -la
```
## she-bang
начало файла:
```
#!/usr/bin/env VAR=VALUE bash
#!/bin/bash
#!/bin/python
```
## Переменные и параметры
параметры:
```
export var=value
var=value # без пробелов
declare var=value
var=`ls`
var=$(uname -r)
var=$((2+3))
var=$(expr 3 + 7)
var1="${var1:-default value}"
```
передача параметров в скрипт:
```
var1=test bash script.sh
```
специальные параметры:
```
$@ — параметр􏰀 скрипта (столбик)
$* - все параметр􏰀 скрипта (строка)
$0 — имя скрипта
$1 , $2 , $3 , ... — параметр􏰀 скрипта, по одному
$# — количество параметров
$? — статус в􏰀хода последней в􏰀полненной команд􏰀
$$ — PID оболочки
$! — PID последней в􏰀полненной в фоновом режиме команд􏰀
```
массивы:
```
files = $(ls) - счит􏰀ваетс􏰁 строка
array=('first element' 'second element' 'third element')
array=([3]='fourth element' [4]='fifth element')
array[0]='first element'
array[1]='second element'
echo ${array[2]}
IFS=$'\n'; echo "${array[*]}"
declare -A array
array[first]='First element'
array[second]='Second element'
array =(0 1 2)
```
условия:
```
if EXPR ; then команд􏰀 ; fi
if EXPR ; then команд􏰀 ; else другие команд􏰀 ; fi
if EXPR ; then команд􏰀; elif EXPR ; then команд􏰀; else другие команд􏰀 ; fi
Нагл􏰁дное различие между [ и [[:
if [ "$answer" = y -o "$answer" = yes ] if [[ $answer =~ ^y(es)?$ ]]
```
операторы для строк:
```
-z          # строка пуста
-n          # строка не пуста
=, (==)     # строки равно
!=          # строки не равно
```
операторы для чисел:
```
-eq         # равно
-ne         # не равно
-lt,(< )    # меньше
-le,(<=)    # меньше или равно
-gt,(>)     # больше
-ge,(>=)    # больше или равно
```
логические операторы: 
```
!           # отрицание логического выражения
-a,(&&)     # логическое «И»
-o,(||)     # логическое «ИЛИ»
```
проверки для файлов:
```
[ -e FILE ] — файл существует?
[ -d FILE ] — это директория?
[ -f FILE ] — это обычный файл?
[ -s FILE ] — размер ненулевой?
[ -r FILE ] — доступен для чтения?
[ -w FILE ] — доступен для записи?
[ -x FILE ] — исполняемый?
```
один из вариантов цикла:
```
i=0
arr=(a b c d e f)
while (( $i < ${#arr[@]} ))
do
    echo "${arr[$i]}"
    ((i++)) 
done
```
регулярки:  
^([a-zA-Z0-9_\-\.\+]+)@([a-zA-Z0-9_\-\.]+)\.([a-zA-Z]{2,5})$
```
^       - начало строки
$       - конец строки
.       - любой символ
\       - экранирование символа
[A-Z]   - диапазоны перечислений
[xyz]   - любой из символов
[^xyz]  - исключенние символ􏰀
*       - любое кол-во символов

{m,n}   - сколько раз может встретитс􏰂 символ от - до
{m}     - точное кол-во встречаемости символа
?       - символ может встретится 0 или 1 раз
+       - л􏰄бое кол-во символов, но хотя бы 1
()      - группировка символов
|       - какой либо из символов

[:alnum:] - A-Za-z0-9.
[:alpha:] - A-Za-z.
[:blank:] - пробел или таб
[:cntrl:] - matches control characters.
[:digit:] - 0-9.
[:graph:] - графические символ􏰀 ASCII 33 - 126 ● [:lower:] a-z.
[:print:] - [:graph:] + пробел
[:space:] - пробел и таб
[:upper:] - A-Z.
[:xdigit:] - hex 0-9A-Fa-f
```
